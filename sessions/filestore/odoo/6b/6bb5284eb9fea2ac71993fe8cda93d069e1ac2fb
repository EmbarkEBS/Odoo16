)]}'
{"version": 3, "sources": ["/survey/static/src/js/libs/chartjs-plugin-datalabels.min.js", "/survey/static/src/js/survey_session_colors.js", "/survey/static/src/js/survey_session_chart.js", "/survey/static/src/js/survey_session_text_answers.js", "/survey/static/src/js/survey_session_leaderboard.js", "/survey/static/src/js/survey_session_manage.js"], "mappings": "AAAA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACPA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrBA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3WA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzEA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/UA;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["/*!\n * chartjs-plugin-datalabels v0.7.0\n * https://chartjs-plugin-datalabels.netlify.com\n * (c) 2019 Chart.js Contributors\n * Released under the MIT license\n */\n!function(t,e){\"object\"==typeof exports&&\"undefined\"!=typeof module?module.exports=e(require(\"chart.js\")):\"function\"==typeof define&&define.amd?define([\"chart.js\"],e):(t=t||self).ChartDataLabels=e(t.Chart)}(this,function(t){\"use strict\";var e=(t=t&&t.hasOwnProperty(\"default\")?t.default:t).helpers,r=function(){if(\"undefined\"!=typeof window){if(window.devicePixelRatio)return window.devicePixelRatio;var t=window.screen;if(t)return(t.deviceXDPI||1)/(t.logicalXDPI||1)}return 1}(),n={toTextLines:function(t){var r,n=[];for(t=[].concat(t);t.length;)\"string\"==typeof(r=t.pop())?n.unshift.apply(n,r.split(\"\\n\")):Array.isArray(r)?t.push.apply(t,r):e.isNullOrUndef(t)||n.unshift(\"\"+r);return n},toFontString:function(t){return!t||e.isNullOrUndef(t.size)||e.isNullOrUndef(t.family)?null:(t.style?t.style+\" \":\"\")+(t.weight?t.weight+\" \":\"\")+t.size+\"px \"+t.family},textSize:function(t,e,r){var n,i=[].concat(e),o=i.length,a=t.font,l=0;for(t.font=r.string,n=0;n<o;++n)l=Math.max(t.measureText(i[n]).width,l);return t.font=a,{height:o*r.lineHeight,width:l}},parseFont:function(r){var i=t.defaults.global,o=e.valueOrDefault(r.size,i.defaultFontSize),a={family:e.valueOrDefault(r.family,i.defaultFontFamily),lineHeight:e.options.toLineHeight(r.lineHeight,o),size:o,style:e.valueOrDefault(r.style,i.defaultFontStyle),weight:e.valueOrDefault(r.weight,null),string:\"\"};return a.string=n.toFontString(a),a},bound:function(t,e,r){return Math.max(t,Math.min(e,r))},arrayDiff:function(t,e){var r,n,i,o,a=t.slice(),l=[];for(r=0,i=e.length;r<i;++r)o=e[r],-1===(n=a.indexOf(o))?l.push([o,1]):a.splice(n,1);for(r=0,i=a.length;r<i;++r)l.push([a[r],-1]);return l},rasterize:function(t){return Math.round(t*r)/r}};function i(t,e){var r=e.x,n=e.y;if(null===r)return{x:0,y:-1};if(null===n)return{x:1,y:0};var i=t.x-r,o=t.y-n,a=Math.sqrt(i*i+o*o);return{x:a?i/a:0,y:a?o/a:-1}}var o=0,a=1,l=2,s=4,u=8;function f(t,e,r){var n=o;return t<r.left?n|=a:t>r.right&&(n|=l),e<r.top?n|=u:e>r.bottom&&(n|=s),n}function d(t,e){var r,n,i=e.anchor,o=t;return e.clamp&&(o=function(t,e){for(var r,n,i,o=t.x0,d=t.y0,c=t.x1,h=t.y1,x=f(o,d,e),y=f(c,h,e);x|y&&!(x&y);)(r=x||y)&u?(n=o+(c-o)*(e.top-d)/(h-d),i=e.top):r&s?(n=o+(c-o)*(e.bottom-d)/(h-d),i=e.bottom):r&l?(i=d+(h-d)*(e.right-o)/(c-o),n=e.right):r&a&&(i=d+(h-d)*(e.left-o)/(c-o),n=e.left),r===x?x=f(o=n,d=i,e):y=f(c=n,h=i,e);return{x0:o,x1:c,y0:d,y1:h}}(o,e.area)),\"start\"===i?(r=o.x0,n=o.y0):\"end\"===i?(r=o.x1,n=o.y1):(r=(o.x0+o.x1)/2,n=(o.y0+o.y1)/2),function(t,e,r,n,i){switch(i){case\"center\":r=n=0;break;case\"bottom\":r=0,n=1;break;case\"right\":r=1,n=0;break;case\"left\":r=-1,n=0;break;case\"top\":r=0,n=-1;break;case\"start\":r=-r,n=-n;break;case\"end\":break;default:i*=Math.PI/180,r=Math.cos(i),n=Math.sin(i)}return{x:t,y:e,vx:r,vy:n}}(r,n,t.vx,t.vy,e.align)}var c={arc:function(t,e){var r=(t.startAngle+t.endAngle)/2,n=Math.cos(r),i=Math.sin(r),o=t.innerRadius,a=t.outerRadius;return d({x0:t.x+n*o,y0:t.y+i*o,x1:t.x+n*a,y1:t.y+i*a,vx:n,vy:i},e)},point:function(t,e){var r=i(t,e.origin),n=r.x*t.radius,o=r.y*t.radius;return d({x0:t.x-n,y0:t.y-o,x1:t.x+n,y1:t.y+o,vx:r.x,vy:r.y},e)},rect:function(t,e){var r=i(t,e.origin),n=t.x,o=t.y,a=0,l=0;return t.horizontal?(n=Math.min(t.x,t.base),a=Math.abs(t.base-t.x)):(o=Math.min(t.y,t.base),l=Math.abs(t.base-t.y)),d({x0:n,y0:o+l,x1:n+a,y1:o,vx:r.x,vy:r.y},e)},fallback:function(t,e){var r=i(t,e.origin);return d({x0:t.x,y0:t.y,x1:t.x,y1:t.y,vx:r.x,vy:r.y},e)}},h=t.helpers,x=n.rasterize;function y(t){var e=t._model.horizontal,r=t._scale||e&&t._xScale||t._yScale;if(!r)return null;if(void 0!==r.xCenter&&void 0!==r.yCenter)return{x:r.xCenter,y:r.yCenter};var n=r.getBasePixel();return e?{x:n,y:null}:{x:null,y:n}}function v(t,e,r){var n=t.shadowBlur,i=r.stroked,o=x(r.x),a=x(r.y),l=x(r.w);i&&t.strokeText(e,o,a,l),r.filled&&(n&&i&&(t.shadowBlur=0),t.fillText(e,o,a,l),n&&i&&(t.shadowBlur=n))}var _=function(t,e,r,n){var i=this;i._config=t,i._index=n,i._model=null,i._rects=null,i._ctx=e,i._el=r};h.extend(_.prototype,{_modelize:function(e,r,i,o){var a,l=this._index,s=h.options.resolve,u=n.parseFont(s([i.font,{}],o,l)),f=s([i.color,t.defaults.global.defaultFontColor],o,l);return{align:s([i.align,\"center\"],o,l),anchor:s([i.anchor,\"center\"],o,l),area:o.chart.chartArea,backgroundColor:s([i.backgroundColor,null],o,l),borderColor:s([i.borderColor,null],o,l),borderRadius:s([i.borderRadius,0],o,l),borderWidth:s([i.borderWidth,0],o,l),clamp:s([i.clamp,!1],o,l),clip:s([i.clip,!1],o,l),color:f,display:e,font:u,lines:r,offset:s([i.offset,0],o,l),opacity:s([i.opacity,1],o,l),origin:y(this._el),padding:h.options.toPadding(s([i.padding,0],o,l)),positioner:(a=this._el,a instanceof t.elements.Arc?c.arc:a instanceof t.elements.Point?c.point:a instanceof t.elements.Rectangle?c.rect:c.fallback),rotation:s([i.rotation,0],o,l)*(Math.PI/180),size:n.textSize(this._ctx,r,u),textAlign:s([i.textAlign,\"start\"],o,l),textShadowBlur:s([i.textShadowBlur,0],o,l),textShadowColor:s([i.textShadowColor,f],o,l),textStrokeColor:s([i.textStrokeColor,f],o,l),textStrokeWidth:s([i.textStrokeWidth,0],o,l)}},update:function(t){var e,r,i,o=this,a=null,l=null,s=o._index,u=o._config,f=h.options.resolve([u.display,!0],t,s);f&&(e=t.dataset.data[s],r=h.valueOrDefault(h.callback(u.formatter,[e,t]),e),(i=h.isNullOrUndef(r)?[]:n.toTextLines(r)).length&&(l=function(t){var e=t.borderWidth||0,r=t.padding,n=t.size.height,i=t.size.width,o=-i/2,a=-n/2;return{frame:{x:o-r.left-e,y:a-r.top-e,w:i+r.width+2*e,h:n+r.height+2*e},text:{x:o,y:a,w:i,h:n}}}(a=o._modelize(f,i,u,t)))),o._model=a,o._rects=l},geometry:function(){return this._rects?this._rects.frame:{}},rotation:function(){return this._model?this._model.rotation:0},visible:function(){return this._model&&this._model.opacity},model:function(){return this._model},draw:function(t,e){var r,i=t.ctx,o=this._model,a=this._rects;this.visible()&&(i.save(),o.clip&&(r=o.area,i.beginPath(),i.rect(r.left,r.top,r.right-r.left,r.bottom-r.top),i.clip()),i.globalAlpha=n.bound(0,o.opacity,1),i.translate(x(e.x),x(e.y)),i.rotate(o.rotation),function(t,e,r){var n=r.backgroundColor,i=r.borderColor,o=r.borderWidth;(n||i&&o)&&(t.beginPath(),h.canvas.roundedRect(t,x(e.x)+o/2,x(e.y)+o/2,x(e.w)-o,x(e.h)-o,r.borderRadius),t.closePath(),n&&(t.fillStyle=n,t.fill()),i&&o&&(t.strokeStyle=i,t.lineWidth=o,t.lineJoin=\"miter\",t.stroke()))}(i,a.frame,o),function(t,e,r,n){var i,o=n.textAlign,a=n.color,l=!!a,s=n.font,u=e.length,f=n.textStrokeColor,d=n.textStrokeWidth,c=f&&d;if(u&&(l||c))for(r=function(t,e,r){var n=r.lineHeight,i=t.w,o=t.x;return\"center\"===e?o+=i/2:\"end\"!==e&&\"right\"!==e||(o+=i),{h:n,w:i,x:o,y:t.y+n/2}}(r,o,s),t.font=s.string,t.textAlign=o,t.textBaseline=\"middle\",t.shadowBlur=n.textShadowBlur,t.shadowColor=n.textShadowColor,l&&(t.fillStyle=a),c&&(t.lineJoin=\"round\",t.lineWidth=d,t.strokeStyle=f),i=0,u=e.length;i<u;++i)v(t,e[i],{stroked:c,filled:l,w:r.w,x:r.x,y:r.y+r.h*i})}(i,o.lines,a.text,o),i.restore())}});var b=t.helpers,p=Number.MIN_SAFE_INTEGER||-9007199254740991,g=Number.MAX_SAFE_INTEGER||9007199254740991;function m(t,e,r){var n=Math.cos(r),i=Math.sin(r),o=e.x,a=e.y;return{x:o+n*(t.x-o)-i*(t.y-a),y:a+i*(t.x-o)+n*(t.y-a)}}function w(t,e){var r,n,i,o,a,l=g,s=p,u=e.origin;for(r=0;r<t.length;++r)i=(n=t[r]).x-u.x,o=n.y-u.y,a=e.vx*i+e.vy*o,l=Math.min(l,a),s=Math.max(s,a);return{min:l,max:s}}function k(t,e){var r=e.x-t.x,n=e.y-t.y,i=Math.sqrt(r*r+n*n);return{vx:(e.x-t.x)/i,vy:(e.y-t.y)/i,origin:t,ln:i}}var M=function(){this._rotation=0,this._rect={x:0,y:0,w:0,h:0}};function S(t,e,r){var n=e.positioner(t,e),i=n.vx,o=n.vy;if(!i&&!o)return{x:n.x,y:n.y};var a=r.w,l=r.h,s=e.rotation,u=Math.abs(a/2*Math.cos(s))+Math.abs(l/2*Math.sin(s)),f=Math.abs(a/2*Math.sin(s))+Math.abs(l/2*Math.cos(s)),d=1/Math.max(Math.abs(i),Math.abs(o));return u*=i*d,f*=o*d,u+=e.offset*i,f+=e.offset*o,{x:n.x+u,y:n.y+f}}b.extend(M.prototype,{center:function(){var t=this._rect;return{x:t.x+t.w/2,y:t.y+t.h/2}},update:function(t,e,r){this._rotation=r,this._rect={x:e.x+t.x,y:e.y+t.y,w:e.w,h:e.h}},contains:function(t){var e=this._rect;return!((t=m(t,this.center(),-this._rotation)).x<e.x-1||t.y<e.y-1||t.x>e.x+e.w+2||t.y>e.y+e.h+2)},intersects:function(t){var e,r,n,i=this._points(),o=t._points(),a=[k(i[0],i[1]),k(i[0],i[3])];for(this._rotation!==t._rotation&&a.push(k(o[0],o[1]),k(o[0],o[3])),e=0;e<a.length;++e)if(r=w(i,a[e]),n=w(o,a[e]),r.max<n.min||n.max<r.min)return!1;return!0},_points:function(){var t=this._rect,e=this._rotation,r=this.center();return[m({x:t.x,y:t.y},r,e),m({x:t.x+t.w,y:t.y},r,e),m({x:t.x+t.w,y:t.y+t.h},r,e),m({x:t.x,y:t.y+t.h},r,e)]}});var C={prepare:function(t){var e,r,n,i,o,a=[];for(e=0,n=t.length;e<n;++e)for(r=0,i=t[e].length;r<i;++r)o=t[e][r],a.push(o),o.$layout={_box:new M,_hidable:!1,_visible:!0,_set:e,_idx:r};return a.sort(function(t,e){var r=t.$layout,n=e.$layout;return r._idx===n._idx?n._set-r._set:n._idx-r._idx}),this.update(a),a},update:function(t){var e,r,n,i,o,a=!1;for(e=0,r=t.length;e<r;++e)i=(n=t[e]).model(),(o=n.$layout)._hidable=i&&\"auto\"===i.display,o._visible=n.visible(),a|=o._hidable;a&&function(t){var e,r,n,i,o,a;for(e=0,r=t.length;e<r;++e)(i=(n=t[e]).$layout)._visible&&(o=n.geometry(),a=S(n._el._model,n.model(),o),i._box.update(a,o,n.rotation()));(function(t,e){var r,n,i,o;for(r=t.length-1;r>=0;--r)for(i=t[r].$layout,n=r-1;n>=0&&i._visible;--n)(o=t[n].$layout)._visible&&i._box.intersects(o._box)&&e(i,o)})(t,function(t,e){var r=t._hidable,n=e._hidable;r&&n||n?e._visible=!1:r&&(t._visible=!1)})}(t)},lookup:function(t,e){var r,n;for(r=t.length-1;r>=0;--r)if((n=t[r].$layout)&&n._visible&&n._box.contains(e))return t[r];return null},draw:function(t,e){var r,n,i,o,a,l;for(r=0,n=e.length;r<n;++r)(o=(i=e[r]).$layout)._visible&&(a=i.geometry(),l=S(i._el._view,i.model(),a),o._box.update(l,a,i.rotation()),i.draw(t,l))}},z=t.helpers,$={align:\"center\",anchor:\"center\",backgroundColor:null,borderColor:null,borderRadius:0,borderWidth:0,clamp:!1,clip:!1,color:void 0,display:!0,font:{family:void 0,lineHeight:1.2,size:void 0,style:void 0,weight:null},formatter:function(t){if(z.isNullOrUndef(t))return null;var e,r,n,i=t;if(z.isObject(t))if(z.isNullOrUndef(t.label))if(z.isNullOrUndef(t.r))for(i=\"\",n=0,r=(e=Object.keys(t)).length;n<r;++n)i+=(0!==n?\", \":\"\")+e[n]+\": \"+t[e[n]];else i=t.r;else i=t.label;return\"\"+i},labels:void 0,listeners:{},offset:4,opacity:1,padding:{top:4,right:4,bottom:4,left:4},rotation:0,textAlign:\"start\",textStrokeColor:void 0,textStrokeWidth:0,textShadowBlur:0,textShadowColor:void 0},O=t.helpers,A=\"$datalabels\",D=\"$default\";function P(t,e,r){if(e){var n,i=r.$context,o=r.$groups;e[o._set]&&(n=e[o._set][o._key])&&!0===O.callback(n,[i])&&(t[A]._dirty=!0,r.update(i))}}function N(t,e){var r,n,i=t[A],o=i._listeners;if(o.enter||o.leave){if(\"mousemove\"===e.type)n=C.lookup(i._labels,e);else if(\"mouseout\"!==e.type)return;r=i._hovered,i._hovered=n,function(t,e,r,n){var i,o;(r||n)&&(r?n?r!==n&&(o=i=!0):o=!0:i=!0,o&&P(t,e.leave,r),i&&P(t,e.enter,n))}(t,o,r,n)}}t.defaults.global.plugins.datalabels=$;var R={id:\"datalabels\",beforeInit:function(t){t[A]={_actives:[]}},beforeUpdate:function(t){var e=t[A];e._listened=!1,e._listeners={},e._datasets=[],e._labels=[]},afterDatasetUpdate:function(t,e,r){var n,i,o,a,l,s,u,f,d=e.index,c=t[A],h=c._datasets[d]=[],x=t.isDatasetVisible(d),y=t.data.datasets[d],v=function(t,e){var r,n,i,o=t.datalabels,a=[];return!1===o?null:(!0===o&&(o={}),e=O.merge({},[e,o]),n=e.labels||{},i=Object.keys(n),delete e.labels,i.length?i.forEach(function(t){n[t]&&a.push(O.merge({},[e,n[t],{_key:t}]))}):a.push(e),r=a.reduce(function(t,e){return O.each(e.listeners||{},function(r,n){t[n]=t[n]||{},t[n][e._key||D]=r}),delete e.listeners,t},{}),{labels:a,listeners:r})}(y,r),b=e.meta.data||[],p=t.ctx;for(p.save(),n=0,o=b.length;n<o;++n)if((u=b[n])[A]=[],x&&u&&!u.hidden&&!u._model.skip)for(i=0,a=v.labels.length;i<a;++i)s=(l=v.labels[i])._key,(f=new _(l,p,u,n)).$groups={_set:d,_key:s||D},f.$context={active:!1,chart:t,dataIndex:n,dataset:y,datasetIndex:d},f.update(f.$context),u[A].push(f),h.push(f);p.restore(),O.merge(c._listeners,v.listeners,{merger:function(t,r,n){r[t]=r[t]||{},r[t][e.index]=n[t],c._listened=!0}})},afterUpdate:function(t,e){t[A]._labels=C.prepare(t[A]._datasets,e)},afterDatasetsDraw:function(t){C.draw(t,t[A]._labels)},beforeEvent:function(t,e){if(t[A]._listened)switch(e.type){case\"mousemove\":case\"mouseout\":N(t,e);break;case\"click\":!function(t,e){var r=t[A],n=r._listeners.click,i=n&&C.lookup(r._labels,e);i&&P(t,n,i)}(t,e)}},afterEvent:function(e){var r,i,o,a,l,s,u,f=e[A],d=f._actives,c=f._actives=e.lastActive||[],h=n.arrayDiff(d,c);for(r=0,i=h.length;r<i;++r)if((l=h[r])[1])for(o=0,a=(u=l[0][A]||[]).length;o<a;++o)(s=u[o]).$context.active=1===l[1],s.update(s.$context);(f._dirty||h.length)&&(C.update(f._labels),function(e){if(!e.animating){for(var r=t.animationService.animations,n=0,i=r.length;n<i;++n)if(r[n].chart===e)return;e.render({duration:1,lazy:!0})}}(e)),delete f._dirty}};return t.plugins.register(R),R});\n", "odoo.define('survey.session_colors', function (require) {\n'use strict';\n\n/**\n * Small tool that returns common colors for survey session widgets.\n * Source: https://www.materialui.co/colors (500)\n */\nreturn [\n    '33,150,243',\n    '63,81,181',\n    '205,220,57',\n    '0,150,136',\n    '76,175,80',\n    '121,85,72',\n    '158,158,158',\n    '156,39,176',\n    '96,125,139',\n    '244,67,54',\n];\n\n});\n", "odoo.define('survey.session_chart', function (require) {\n'use strict';\n\nvar publicWidget = require('web.public.widget');\nvar SESSION_CHART_COLORS = require('survey.session_colors');\n\npublicWidget.registry.SurveySessionChart = publicWidget.Widget.extend({\n    init: function (parent, options) {\n        this._super.apply(this, arguments);\n\n        this.questionType = options.questionType;\n        this.answersValidity = options.answersValidity;\n        this.hasCorrectAnswers = options.hasCorrectAnswers;\n        this.questionStatistics = this._processQuestionStatistics(options.questionStatistics);\n        this.showInputs = options.showInputs;\n        this.showAnswers = false;\n    },\n\n    start: function () {\n        var self = this;\n        return this._super.apply(this, arguments).then(function () {\n            self._setupChart();\n        });\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Updates the chart data using the latest received question user inputs.\n     *\n     * By updating the numbers in the dataset, we take advantage of the Chartjs API\n     * that will automatically add animations to show the new number.\n     *\n     * @param {Object} questionStatistics object containing chart data (counts / labels / ...)\n     * @param {Integer} newAttendeesCount: max height of chart, not used anymore (deprecated)\n     */\n    updateChart: function (questionStatistics, newAttendeesCount) {\n        if (questionStatistics) {\n            this.questionStatistics = this._processQuestionStatistics(questionStatistics);\n        }\n\n        if (this.chart) {\n            // only a single dataset for our bar charts\n            var chartData = this.chart.data.datasets[0].data;\n            for (var i = 0; i < chartData.length; i++){\n                var value = 0;\n                if (this.showInputs) {\n                    value = this.questionStatistics[i].count;\n                }\n                this.chart.data.datasets[0].data[i] = value;\n            }\n\n            this.chart.update();\n        }\n    },\n\n    /**\n     * Toggling this parameter will display or hide the correct and incorrect answers of the current\n     * question directly on the chart.\n     *\n     * @param {Boolean} showAnswers\n     */\n    setShowAnswers: function (showAnswers) {\n        this.showAnswers = showAnswers;\n    },\n\n    /**\n     * Toggling this parameter will display or hide the user inputs of the current question directly\n     * on the chart.\n     *\n     * @param {Boolean} showInputs\n     */\n    setShowInputs: function (showInputs) {\n        this.showInputs = showInputs;\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     */\n    _setupChart: function () {\n        var $canvas = this.$('canvas');\n        var ctx = $canvas.get(0).getContext('2d');\n\n        this.chart = new Chart(ctx, this._buildChartConfiguration());\n    },\n\n    /**\n     * Custom bar chart configuration for our survey session use case.\n     *\n     * Quick summary of enabled features:\n     * - background_color is one of the 10 custom colors from SESSION_CHART_COLORS\n     *   (see _getBackgroundColor for details)\n     * - The ticks are bigger and bolded to be able to see them better on a big screen (projector)\n     * - We don't use tooltips to keep it as simple as possible\n     * - We don't set a suggestedMin or Max so that Chart will adapt automatically based on the given data\n     *   The '+1' part is a small trick to avoid the datalabels to be clipped in height\n     * - We use a custom 'datalabels' plugin to be able to display the number value on top of the\n     *   associated bar of the chart.\n     *   This allows the host to discuss results with attendees in a more interactive way.\n     *\n     * @private\n     */\n    _buildChartConfiguration: function () {\n        return {\n            type: 'bar',\n            data: {\n                labels: this._extractChartLabels(),\n                datasets: [{\n                    backgroundColor: this._getBackgroundColor.bind(this),\n                    data: this._extractChartData(),\n                }]\n            },\n            options: {\n                maintainAspectRatio: false,\n                plugins: {\n                    datalabels: {\n                        color: this._getLabelColor.bind(this),\n                        font: {\n                            size: '50',\n                            weight: 'bold',\n                        },\n                        anchor: 'end',\n                        align: 'top',\n                    }\n                },\n                legend: {\n                    display: false,\n                },\n                scales: {\n                    yAxes: [{\n                        ticks: {\n                            display: false,\n                        },\n                        gridLines: {\n                            display: false\n                        }\n                    }],\n                    xAxes: [{\n                        ticks: {\n                            maxRotation: 0,\n                            fontSize: '35',\n                            fontStyle: 'bold',\n                            fontColor: '#212529'\n                        },\n                        gridLines: {\n                            drawOnChartArea: false,\n                            color: 'rgba(0, 0, 0, 0.2)'\n                        }\n                    }]\n                },\n                tooltips: {\n                    enabled: false,\n                },\n                layout: {\n                    padding: {\n                        left: 0,\n                        right: 0,\n                        top: 70,\n                        bottom: 0\n                    }\n                }\n            },\n            plugins: [{\n                /**\n                 * The way it works is each label is an array of words.\n                 * eg.: if we have a chart label: \"this is an example of a label\"\n                 * The library will split it as: [\"this is an example\", \"of a label\"]\n                 * Each value of the array represents a line of the label.\n                 * So for this example above: it will be displayed as:\n                 * \"this is an examble<br/>of a label\", breaking the label in 2 parts and put on 2 lines visually.\n                 * \n                 * What we do here is rework the labels with our own algorithm to make them fit better in screen space\n                 * based on breakpoints based on number of columns to display.\n                 * So this example will become: [\"this is an\", \"example of\", \"a label\"] if we have a lot of labels to put in the chart.\n                 * Which will be displayed as \"this is an<br/>example of<br/>a label\"\n                 * Obviously, the more labels you have, the more columns, and less screen space is available.\n                 * \n                 * We also adapt the font size based on the width available in the chart.\n                 * \n                 * So we counterbalance multiple times:\n                 * - Based on number of columns (i.e. number of survey.question.answer of your current survey.question),\n                 *   we split the words of every labels to make them display on more rows.\n                 * - Based on the width of the chart (which is equivalent to screen width),\n                 *   we reduce the chart font to be able to fit more characters.\n                 * - Based on the longest word present in the labels, we apply a certain ratio with the width of the chart\n                 *   to get a more accurate font size for the space available.\n                 * \n                 * @param {Object} chart \n                 */\n                beforeInit: function (chart) {\n                    const nbrCol = chart.data.labels.length;\n                    const minRatio = 0.4;\n                    // Numbers of maximum characters per line to print based on the number of columns and default ratio for the font size\n                    // Between 1 and 2 -> 25, 3 and 4 -> 20, 5 and 6 -> 15, ...\n                    const charPerLineBreakpoints = [\n                        [1, 2, 25, minRatio],\n                        [3, 4, 20, minRatio],\n                        [5, 6, 15, 0.45],\n                        [7, 8, 10, 0.65],\n                        [9, null, 7, 0.7],\n                    ];\n\n                    let charPerLine;\n                    let fontRatio;\n                    charPerLineBreakpoints.forEach(([lowerBound, upperBound, value, ratio]) => {\n                        if (nbrCol >= lowerBound && (upperBound === null || nbrCol <= upperBound)) {\n                            charPerLine = value;\n                            fontRatio = ratio;\n                        }\n                    });\n\n                    // Adapt font size if the number of characters per line is under the maximum\n                    if (charPerLine < 25) {\n                        const allWords = chart.data.labels.reduce((accumulator, words) => accumulator.concat(' '.concat(words)));\n                        const maxWordLength = Math.max(...allWords.split(' ').map((word) => word.length));\n                        fontRatio = maxWordLength > charPerLine ? minRatio : fontRatio;\n                        chart.options.scales.xAxes[0].ticks.fontSize = Math.min(parseInt(chart.options.scales.xAxes[0].ticks.fontSize), chart.width * fontRatio / (nbrCol));\n                    }\n\n                    chart.data.labels.forEach(function (label, index, labelsList) {\n                        // Split all the words of the label\n                        const words = label.split(\" \");\n                        let resultLines = [];\n                        let currentLine = [];\n                        for (let i = 0; i < words.length; i++) {\n                            // If the word we are adding exceed already the number of characters for the line, we add it anyway before passing to a new line\n                            currentLine.push(words[i]);\n\n                            // Continue to add words in the line if there is enough space and if there is at least one more word to add\n                            const nextWord = i+1 < words.length ? words[i+1] : null;\n                            if (nextWord) {\n                                const nextLength = currentLine.join(' ').length + nextWord.length;\n                                if (nextLength <= charPerLine) {\n                                    continue;\n                                }\n                            }\n                            // Add the constructed line and reset the variable for the next line\n                            const newLabelLine = currentLine.join(' ');\n                            resultLines.push(newLabelLine);\n                            currentLine = [];\n                        }\n                        labelsList[index] = resultLines;\n                    });\n                },\n            }],\n        };\n    },\n\n    /**\n     * Returns the label of the associated survey.question.answer.\n     *\n     * @private\n     */\n    _extractChartLabels: function () {\n        return this.questionStatistics.map(function (point) {\n            return point.text;\n        });\n    },\n\n    /**\n     * We simply return an array of zeros as initial value.\n     * The chart will update afterwards as attendees add their user inputs.\n     *\n     * @private\n     */\n    _extractChartData: function () {\n        return this.questionStatistics.map(function () {\n            return 0;\n        });\n    },\n\n    /**\n     * Custom method that returns a color from SESSION_CHART_COLORS.\n     * It loops through the ten values and assign them sequentially.\n     *\n     * We have a special mechanic when the host shows the answers of a question.\n     * Wrong answers are \"faded out\" using a 0.3 opacity.\n     *\n     * @param {Object} metaData\n     * @param {Integer} metaData.dataIndex the index of the label, matching the index of the answer\n     *   in 'this.answersValidity'\n     * @private\n     */\n    _getBackgroundColor: function (metaData) {\n        var opacity = '0.8';\n        if (this.showAnswers && this.hasCorrectAnswers) {\n            if (!this._isValidAnswer(metaData.dataIndex)){\n                opacity = '0.2';\n            }\n        }\n        var rgb = SESSION_CHART_COLORS[metaData.dataIndex];\n        return `rgba(${rgb},${opacity})`;\n    },\n\n    /**\n     * Custom method that returns the survey.question.answer label color.\n     *\n     * Break-down of use cases:\n     * - Red if the host is showing answer, and the associated answer is not correct\n     * - Green if the host is showing answer, and the associated answer is correct\n     * - Black in all other cases\n     *\n     * @param {Object} metaData\n     * @param {Integer} metaData.dataIndex the index of the label, matching the index of the answer\n     *   in 'this.answersValidity'\n     * @private\n     */\n    _getLabelColor: function (metaData) {\n        if (this.showAnswers && this.hasCorrectAnswers) {\n            if (this._isValidAnswer(metaData.dataIndex)){\n                return '#2CBB70';\n            } else {\n                return '#D9534F';\n            }\n        }\n        return '#212529';\n    },\n\n    /**\n     * Small helper method that returns the validity of the answer based on its index.\n     *\n     * We need this special handling because of Chartjs data structure.\n     * The library determines the parameters (color/label/...) by only passing the answer 'index'\n     * (and not the id or anything else we can identify).\n     *\n     * @param {Integer} answerIndex\n     * @private\n     */\n    _isValidAnswer: function (answerIndex) {\n        return this.answersValidity[answerIndex];\n    },\n\n    /**\n     * Special utility method that will process the statistics we receive from the\n     * survey.question#_prepare_statistics method.\n     *\n     * For multiple choice questions, the values we need are stored in a different place.\n     * We simply return the values to make the use of the statistics common for both simple and\n     * multiple choice questions.\n     *\n     * See survey.question#_get_stats_data for more details\n     *\n     * @param {Object} rawStatistics\n     * @private\n     */\n    _processQuestionStatistics: function (rawStatistics) {\n        if (this.questionType === 'multiple_choice') {\n            return rawStatistics[0].values;\n        }\n\n        return rawStatistics;\n    }\n});\n\nreturn publicWidget.registry.SurveySessionChart;\n\n});\n", "odoo.define('survey.session_text_answers', function (require) {\n'use strict';\n\nvar publicWidget = require('web.public.widget');\nvar core = require('web.core');\nvar time = require('web.time');\nvar SESSION_CHART_COLORS = require('survey.session_colors');\n\nvar QWeb = core.qweb;\n\npublicWidget.registry.SurveySessionTextAnswers = publicWidget.Widget.extend({\n    init: function (parent, options) {\n        this._super.apply(this, arguments);\n\n        this.answerIds = [];\n        this.questionType = options.questionType;\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Adds the attendees answers on the screen.\n     * This is used for char_box/date and datetime questions.\n     *\n     * We use some tricks with jQuery for wow effect:\n     * - force a width on the external div container, to reserve space for that answer\n     * - set the actual width of the answer, and enable a css width animation\n     * - set the opacity to 1, and enable a css opacity animation\n     *\n     * @param {Array} inputLineValues array of survey.user_input.line records in the form\n     *   {id: line.id, value: line.[value_char_box/value_date/value_datetime]}\n     */\n    updateTextAnswers: function (inputLineValues) {\n        var self = this;\n\n        inputLineValues.forEach(function (inputLineValue) {\n            if (!self.answerIds.includes(inputLineValue.id) && inputLineValue.value) {\n                var textValue = inputLineValue.value;\n                if (self.questionType === 'char_box') {\n                    textValue = textValue.length > 25 ?\n                        textValue.substring(0, 22) + '...' :\n                        textValue;\n                } else if (self.questionType === 'date') {\n                    textValue = moment(textValue).format(time.getLangDateFormat());\n                } else if (self.questionType === 'datetime') {\n                    textValue = moment(textValue).format(time.getLangDatetimeFormat());\n                }\n\n                var $textAnswer = $(QWeb.render('survey.survey_session_text_answer', {\n                    value: textValue,\n                    borderColor: `rgb(${SESSION_CHART_COLORS[self.answerIds.length % 10]})`\n                }));\n                self.$el.append($textAnswer);\n                var spanWidth = $textAnswer.find('span').width();\n                var calculatedWidth = `calc(${spanWidth}px + 1.2rem)`;\n                $textAnswer.css('width', calculatedWidth);\n                setTimeout(function () {\n                    // setTimeout to force jQuery rendering\n                    $textAnswer.find('.o_survey_session_text_answer_container')\n                        .css('width', calculatedWidth)\n                        .css('opacity', '1');\n                }, 1);\n                self.answerIds.push(inputLineValue.id);\n            }\n        });\n    },\n});\n\nreturn publicWidget.registry.SurveySessionTextAnswers;\n\n});\n", "odoo.define('survey.session_leaderboard', function (require) {\n'use strict';\n\nvar publicWidget = require('web.public.widget');\nvar SESSION_CHART_COLORS = require('survey.session_colors');\n\npublicWidget.registry.SurveySessionLeaderboard = publicWidget.Widget.extend({\n    init: function (parent, options) {\n        this._super.apply(this, arguments);\n\n        this.surveyAccessToken = options.surveyAccessToken;\n        this.$sessionResults = options.sessionResults;\n\n        this.BAR_MIN_WIDTH = '3rem';\n        this.BAR_WIDTH = '24rem';\n        this.BAR_HEIGHT = '3.8rem';\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Shows the question leaderboard on screen.\n     * It's based on the attendees score (descending).\n     *\n     * We fade out the $sessionResults to fade in our rendered template.\n     *\n     * The width of the progress bars is set after the rendering to enable a width css animation.\n     */\n    showLeaderboard: function (fadeOut, isScoredQuestion) {\n        var self = this;\n\n        var resolveFadeOut;\n        var fadeOutPromise;\n        if (fadeOut) {\n            fadeOutPromise = new Promise(function (resolve, reject) { resolveFadeOut = resolve; });\n            self.$sessionResults.fadeOut(400, function () {\n                resolveFadeOut();\n            });\n        } else {\n            fadeOutPromise = Promise.resolve();\n            self.$sessionResults.hide();\n            self.$('.o_survey_session_leaderboard_container').empty();\n        }\n\n        var leaderboardPromise = this._rpc({\n            route: _.str.sprintf('/survey/session/leaderboard/%s', this.surveyAccessToken)\n        });\n\n        Promise.all([fadeOutPromise, leaderboardPromise]).then(function (results) {\n            var leaderboardResults = results[1];\n            var $renderedTemplate = $(leaderboardResults);\n            self.$('.o_survey_session_leaderboard_container').append($renderedTemplate);\n\n            self.$('.o_survey_session_leaderboard_item').each(function (index) {\n                var rgb = SESSION_CHART_COLORS[index % 10];\n                $(this)\n                    .find('.o_survey_session_leaderboard_bar')\n                    .css('background-color', `rgba(${rgb},1)`);\n                $(this)\n                    .find('.o_survey_session_leaderboard_bar_question')\n                    .css('background-color', `rgba(${rgb},${0.4})`);\n            });\n\n            self.$el.fadeIn(400, async function () {\n                if (isScoredQuestion) {\n                    await self._prepareScores();\n                    await self._showQuestionScores();\n                    await self._sumScores();\n                    await self._reorderScores();\n                }\n            });\n        });\n    },\n\n    /**\n     * Inverse the process, fading out our template to fade int the $sessionResults.\n     */\n    hideLeaderboard: function () {\n        var self = this;\n        this.$el.fadeOut(400, function () {\n            self.$('.o_survey_session_leaderboard_container').empty();\n            self.$sessionResults.fadeIn(400);\n        });\n    },\n\n    /**\n     * This method animates the passed jQuery element from 0 points to {totalScore} points.\n     * It will create a nice \"animated\" effect of a counter increasing by {increment} until it\n     * reaches the actual score.\n     *\n     * @param {$.Element} $scoreEl the element to animate\n     * @param {Integer} currentScore the currently displayed score\n     * @param {Integer} totalScore to total score to animate to\n     * @param {Integer} increment the base increment of each animation iteration\n     * @param {Boolean} plusSign wether or not we add a \"+\" before the score\n     * @private\n     */\n    _animateScoreCounter: function ($scoreEl, currentScore, totalScore, increment, plusSign) {\n        var self = this;\n        setTimeout(function () {\n            var nextScore = currentScore + increment;\n            if (nextScore > totalScore) {\n                nextScore = totalScore;\n            }\n            $scoreEl.text(`${plusSign ? '+ ' : ''}${Math.round(nextScore)} p`);\n\n            if (nextScore < totalScore) {\n                self._animateScoreCounter($scoreEl, nextScore, totalScore, increment, plusSign);\n            }\n        }, 25);\n    },\n\n    /**\n     * Helper to move a score bar from its current position in the leaderboard\n     * to a new position.\n     *\n     * @param {$.Element} $score the score bar to move\n     * @param {Integer} position the new position in the leaderboard\n     * @param {Integer} offset an offset in 'rem'\n     * @param {Integer} timeout time to wait while moving before resolving the promise\n     */\n    _animateMoveTo: function ($score, position, offset, timeout) {\n        var animationDone;\n        var animationPromise = new Promise(function (resolve) {\n            animationDone = resolve;\n        });\n        $score.css('top', `calc(calc(${this.BAR_HEIGHT} * ${position}) + ${offset}rem)`);\n        setTimeout(animationDone, timeout);\n        return animationPromise;\n    },\n\n    /**\n     * Takes the leaderboard prior to the current question results\n     * and reduce all scores bars to a small width (3rem).\n     * We keep the small score bars on screen for 1s.\n     *\n     * This visually prepares the display of points for the current question.\n     *\n     * @private\n     */\n    _prepareScores: function () {\n        var self = this;\n        var animationDone;\n        var animationPromise = new Promise(function (resolve) {\n            animationDone = resolve;\n        });\n        setTimeout(function () {\n            this.$('.o_survey_session_leaderboard_bar').each(function () {\n                var currentScore = parseInt($(this)\n                    .closest('.o_survey_session_leaderboard_item')\n                    .data('currentScore'))\n                if (currentScore && currentScore !== 0) {\n                    $(this).css('transition', `width 1s cubic-bezier(.4,0,.4,1)`);\n                    $(this).css('width', self.BAR_MIN_WIDTH);\n                }\n            });\n            setTimeout(animationDone, 1000);\n        }, 300);\n\n        return animationPromise;\n    },\n\n    /**\n     * Now that we have summed the score for the current question to the total score\n     * of the user and re-weighted the bars accordingly, we need to re-order everything\n     * to match the new ranking.\n     *\n     * In addition to moving the bars to their new position, we create a \"bounce\" effect\n     * by moving the bar a little bit more to the top or bottom (depending on if it's moving up\n     * the ranking or down), the moving it the other way around, then moving it to its final\n     * position.\n     *\n     * (Feels complicated when explained but it's fairly simple once you see what it does).\n     *\n     * @private\n     */\n    _reorderScores: function () {\n        var self = this;\n        var animationDone;\n        var animationPromise = new Promise(function (resolve) {\n            animationDone = resolve;\n        });\n        setTimeout(function () {\n            self.$('.o_survey_session_leaderboard_item').each(async function () {\n                var $score = $(this);\n                var currentPosition = parseInt($(this).data('currentPosition'));\n                var newPosition = parseInt($(this).data('newPosition'));\n                if (currentPosition !== newPosition) {\n                    var offset = newPosition > currentPosition ? 2 : -2;\n                    await self._animateMoveTo($score, newPosition, offset, 300);\n                    $score.css('transition', 'top ease-in-out .1s');\n                    await self._animateMoveTo($score, newPosition, offset * -0.3, 100);\n                    await self._animateMoveTo($score, newPosition, 0, 0);\n                    animationDone();\n                }\n            });\n        }, 1800);\n\n        return animationPromise;\n    },\n\n    /**\n     * Will display the score for the current question.\n     * We simultaneously:\n     * - increase the width of \"question bar\"\n     *   (faded out bar right next to the global score one)\n     * - animate the score for the question (ex: from + 0 p to + 40 p)\n     *\n     * (We keep a minimum width of 3rem to be able to display '+30 p' within the bar).\n     *\n     * @private\n     */\n    _showQuestionScores: function () {\n        var self = this;\n        var animationDone;\n        var animationPromise = new Promise(function (resolve) {\n            animationDone = resolve;\n        });\n        setTimeout(function () {\n            this.$('.o_survey_session_leaderboard_bar_question').each(function () {\n                var $barEl = $(this);\n                var width = `calc(calc(100% - ${self.BAR_WIDTH}) * ${$barEl.data('widthRatio')} + ${self.BAR_MIN_WIDTH})`;\n                $barEl.css('transition', 'width 1s ease-out');\n                $barEl.css('width', width);\n\n                var $scoreEl = $barEl\n                    .find('.o_survey_session_leaderboard_bar_question_score')\n                    .text('0 p');\n                var questionScore = parseInt($barEl.data('questionScore'));\n                if (questionScore && questionScore > 0) {\n                    var increment = parseInt($barEl.data('maxQuestionScore') / 40);\n                    if (!increment || increment === 0){\n                        increment = 1;\n                    }\n                    $scoreEl.text('+ 0 p');\n                    console.log($barEl.data('maxQuestionScore'));\n                    setTimeout(function () {\n                        self._animateScoreCounter(\n                            $scoreEl,\n                            0,\n                            questionScore,\n                            increment,\n                            true);\n                    }, 400);\n                }\n                setTimeout(animationDone, 1400);\n            });\n        }, 300);\n\n        return animationPromise;\n    },\n\n    /**\n     * After displaying the score for the current question, we sum the total score\n     * of the user so far with the score of the current question.\n     *\n     * Ex:\n     * We have ('#' for total score before question and '=' for current question score):\n     * 210 p ####=================================== +30 p John\n     * We want:\n     * 240 p ###################################==== +30 p John\n     *\n     * Of course, we also have to weight the bars based on the maximum score.\n     * So if John here has 50% of the points of the leader user, both the question score bar\n     * and the total score bar need to have their width divided by 2:\n     * 240 p ##################== +30 p John\n     *\n     * The width of both bars move at the same time to reach their new position,\n     * with an animation on the width property.\n     * The new width of the \"question bar\" should represent the ratio of won points\n     * when compared to the total points.\n     * (We keep a minimum width of 3rem to be able to display '+30 p' within the bar).\n     *\n     * The updated total score is animated towards the new value.\n     * we keep this on screen for 500ms before reordering the bars.\n     *\n     * @private\n     */\n    _sumScores: function () {\n        var self = this;\n        var animationDone;\n        var animationPromise = new Promise(function (resolve) {\n            animationDone = resolve;\n        });\n        // values that felt the best after a lot of testing\n        var growthAnimation = 'cubic-bezier(.5,0,.66,1.11)';\n        setTimeout(function () {\n            this.$('.o_survey_session_leaderboard_item').each(function () {\n                var currentScore = parseInt($(this).data('currentScore'));\n                var updatedScore = parseInt($(this).data('updatedScore'));\n                var increment = parseInt($(this).data('maxQuestionScore') / 40);\n                if (!increment || increment === 0){\n                    increment = 1;\n                }\n                self._animateScoreCounter(\n                    $(this).find('.o_survey_session_leaderboard_score'),\n                    currentScore,\n                    updatedScore,\n                    increment,\n                    false);\n\n                var maxUpdatedScore = parseInt($(this).data('maxUpdatedScore'));\n                var baseRatio = updatedScore / maxUpdatedScore;\n                var questionScore = parseInt($(this).data('questionScore'));\n                var questionRatio = questionScore /\n                    (updatedScore && updatedScore !== 0 ? updatedScore : 1);\n                // we keep a min fixed with of 3rem to be able to display \"+ 5 p\"\n                // even if the user already has 1.000.000 points\n                var questionWith = `calc(calc(calc(100% - ${self.BAR_WIDTH}) * ${questionRatio * baseRatio}) + ${self.BAR_MIN_WIDTH})`;\n                $(this)\n                    .find('.o_survey_session_leaderboard_bar_question')\n                    .css('transition', `width ease .5s ${growthAnimation}`)\n                    .css('width', questionWith);\n\n                var updatedScoreRatio = 1 - questionRatio;\n                var updatedScoreWidth = `calc(calc(100% - ${self.BAR_WIDTH}) * ${updatedScoreRatio * baseRatio})`;\n                $(this)\n                    .find('.o_survey_session_leaderboard_bar')\n                    .css('min-width', '0px')\n                    .css('transition', `width ease .5s ${growthAnimation}`)\n                    .css('width', updatedScoreWidth);\n\n                setTimeout(animationDone, 500);\n            });\n        }, 1400);\n\n        return animationPromise;\n    }\n});\n\nreturn publicWidget.registry.SurveySessionLeaderboard;\n\n});\n", "odoo.define('survey.session_manage', function (require) {\n'use strict';\n\nvar publicWidget = require('web.public.widget');\nvar SurveyPreloadImageMixin = require('survey.preload_image_mixin');\nvar SurveySessionChart = require('survey.session_chart');\nvar SurveySessionTextAnswers = require('survey.session_text_answers');\nvar SurveySessionLeaderBoard = require('survey.session_leaderboard');\nvar core = require('web.core');\nvar _t = core._t;\n\npublicWidget.registry.SurveySessionManage = publicWidget.Widget.extend(SurveyPreloadImageMixin, {\n    selector: '.o_survey_session_manage',\n    events: {\n        'click .o_survey_session_copy': '_onCopySessionLink',\n        'click .o_survey_session_navigation_next, .o_survey_session_start': '_onNext',\n        'click .o_survey_session_navigation_previous': '_onBack',\n        'click .o_survey_session_close': '_onEndSessionClick',\n    },\n\n    /**\n     * Overridden to set a few properties that come from the python template rendering.\n     *\n     * We also handle the timer IF we're not \"transitioning\", meaning a fade out of the previous\n     * $el to the next question (the fact that we're transitioning is in the isRpcCall data).\n     * If we're transitioning, the timer is handled manually at the end of the transition.\n     */\n    start: function () {\n        var self = this;\n        this.fadeInOutTime = 500;\n        return this._super.apply(this, arguments).then(function () {\n            if (self.$el.data('isSessionClosed')) {\n                self._displaySessionClosedPage();\n                self.$el.removeClass('invisible');\n                return;\n            }\n            // general survey props\n            self.surveyId = self.$el.data('surveyId');\n            self.surveyAccessToken = self.$el.data('surveyAccessToken');\n            self.isStartScreen = self.$el.data('isStartScreen');\n            self.isFirstQuestion = self.$el.data('isFirstQuestion');\n            self.isLastQuestion = self.$el.data('isLastQuestion');\n            // scoring props\n            self.isScoredQuestion = self.$el.data('isScoredQuestion');\n            self.sessionShowLeaderboard = self.$el.data('sessionShowLeaderboard');\n            self.hasCorrectAnswers = self.$el.data('hasCorrectAnswers');\n            // display props\n            self.showBarChart = self.$el.data('showBarChart');\n            self.showTextAnswers = self.$el.data('showTextAnswers');\n            // Question transition\n            self.stopNextQuestion = false;\n            // Background Management\n            self.refreshBackground = self.$el.data('refreshBackground');\n            // Copy link tooltip\n            self.$('.o_survey_session_copy').tooltip({delay: 0, title: 'Click to copy link', placement: 'right'});\n\n            var isRpcCall = self.$el.data('isRpcCall');\n            if (!isRpcCall) {\n                self._startTimer();\n                $(document).on('keydown', self._onKeyDown.bind(self));\n            }\n\n            self._setupIntervals();\n            self._setupCurrentScreen();\n            var setupPromises = [];\n            setupPromises.push(self._setupTextAnswers());\n            setupPromises.push(self._setupChart());\n            setupPromises.push(self._setupLeaderboard());\n\n            self.$el.removeClass('invisible');\n            return Promise.all(setupPromises);\n        });\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Copies the survey URL link to the clipboard.\n     * We use 'ClipboardJS' to avoid having to print the URL in a standard text input\n     *\n     * @param {MouseEvent} ev\n     */\n    _onCopySessionLink: function (ev) {\n        var self = this;\n        ev.preventDefault();\n\n        var $clipboardBtn = this.$('.o_survey_session_copy');\n\n        $clipboardBtn.popover({\n            placement: 'right',\n            container: 'body',\n            offset: '0, 3',\n            content: function () {\n                return _t(\"Copied !\");\n            }\n        });\n\n        var clipboard = new ClipboardJS('.o_survey_session_copy', {\n            text: function () {\n                return self.$('.o_survey_session_copy_url').val();\n            },\n            container: this.el\n        });\n\n        clipboard.on('success', function () {\n            clipboard.destroy();\n            $clipboardBtn.popover('show');\n            _.delay(function () {\n                $clipboardBtn.popover('hide');\n            }, 800);\n        });\n\n        clipboard.on('error', function (e) {\n            clipboard.destroy();\n        });\n    },\n\n    /**\n     * Listeners for keyboard arrow / spacebar keys.\n     *\n     * - 39 = arrow-right\n     * - 32 = spacebar\n     * - 37 = arrow-left\n     *\n     * @param {KeyboardEvent} ev\n     */\n    _onKeyDown: function (ev) {\n        var keyCode = ev.keyCode;\n\n        if (keyCode === 39 || keyCode === 32) {\n            this._onNext(ev);\n        } else if (keyCode === 37) {\n            this._onBack(ev);\n        }\n    },\n\n    /**\n     * Handles the \"next screen\" behavior.\n     * It happens when the host uses the keyboard key / button to go to the next screen.\n     * The result depends on the current screen we're on.\n     *\n     * Possible values of the \"next screen\" to display are:\n     * - 'userInputs' when going from a question to the display of attendees' survey.user_input.line\n     *   for that question.\n     * - 'results' when going from the inputs to the actual correct / incorrect answers of that\n     *   question. Only used for scored simple / multiple choice questions.\n     * - 'leaderboard' (or 'leaderboardFinal') when going from the correct answers of a question to\n     *   the leaderboard of attendees. Only used for scored simple / multiple choice questions.\n     * - If it's not one of the above: we go to the next question, or end the session if we're on\n     *   the last question of this session.\n     *\n     * See '_getNextScreen' for a detailed logic.\n     *\n     * @param {Event} ev\n     */\n    _onNext: function (ev) {\n        ev.preventDefault();\n\n        var screenToDisplay = this._getNextScreen();\n\n        if (screenToDisplay === 'userInputs') {\n            this._setShowInputs(true);\n        } else if (screenToDisplay === 'results') {\n            this._setShowAnswers(true);\n            // when showing results, stop refreshing answers\n            clearInterval(this.resultsRefreshInterval);\n            delete this.resultsRefreshInterval;\n        } else if (['leaderboard', 'leaderboardFinal'].includes(screenToDisplay)\n                   && !['leaderboard', 'leaderboardFinal'].includes(this.currentScreen)) {\n            if (this.isLastQuestion) {\n                this.$('.o_survey_session_navigation_next').addClass('d-none');\n            }\n            this.leaderBoard.showLeaderboard(true, this.isScoredQuestion);\n        } else if (!this.isLastQuestion || !this.sessionShowLeaderboard) {\n            this._nextQuestion();\n        }\n\n        this.currentScreen = screenToDisplay;\n    },\n\n    /**\n     * Reverse behavior of '_onNext'.\n     *\n     * @param {Event} ev\n     */\n    _onBack: function (ev) {\n        ev.preventDefault();\n\n        var screenToDisplay = this._getPreviousScreen();\n\n        if (screenToDisplay === 'question') {\n            this._setShowInputs(false);\n        } else if (screenToDisplay === 'userInputs') {\n            this._setShowAnswers(false);\n            // resume refreshing answers if necessary\n            if (!this.resultsRefreshInterval) {\n                this.resultsRefreshInterval = setInterval(this._refreshResults.bind(this), 2000);\n            }\n        } else if (screenToDisplay === 'results') {\n            if (this.leaderBoard) {\n                this.leaderBoard.hideLeaderboard();\n            }\n            // when showing results, stop refreshing answers\n            clearInterval(this.resultsRefreshInterval);\n            delete this.resultsRefreshInterval;\n        } else if (screenToDisplay === 'previousQuestion') {\n            if (this.isFirstQuestion) {\n                return;  // nothing to go back to, we're on the first question\n            }\n            this._nextQuestion(true);\n        }\n\n        this.currentScreen = screenToDisplay;\n    },\n\n    /**\n     * Marks this session as 'done' and redirects the user to the results based on the clicked link.\n     *\n     * @param {MouseEvent} ev\n     * @private\n    */\n    _onEndSessionClick: function (ev) {\n        var self = this;\n        ev.preventDefault();\n\n        this._rpc({\n            model: 'survey.survey',\n            method: 'action_end_session',\n            args: [[this.surveyId]],\n        }).then(function () {\n            if ($(ev.currentTarget).data('showResults')) {\n                document.location = _.str.sprintf(\n                    '/survey/results/%s',\n                    self.surveyId\n                );\n            } else {\n                window.history.back();\n            }\n        });\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Business logic that determines the 'next screen' based on the current screen and the question\n     * configuration.\n     *\n     * Breakdown of use cases:\n     * - If we're on the 'question' screen, and the question is scored, we move to the 'userInputs'\n     * - If we're on the 'question' screen and it's NOT scored, then we move to\n     *     - 'results' if the question has correct / incorrect answers\n     *       (but not scored, which is kind of a corner case)\n     *     - 'nextQuestion' otherwise\n     * - If we're on the 'userInputs' screen and the question has answers, we move to the 'results'\n     * - If we're on the 'results' and the question is scored, we move to the 'leaderboard'\n     * - In all other cases, we show the next question\n     * - (Small exception for the last question: we show the \"final leaderboard\")\n     *\n     * (For details about which screen shows what, see '_onNext')\n     */\n    _getNextScreen: function () {\n        if (this.currentScreen === 'question' && this.isScoredQuestion) {\n            return 'userInputs';\n        } else if (this.hasCorrectAnswers && ['question', 'userInputs'].includes(this.currentScreen)) {\n            return 'results';\n        } else if (this.sessionShowLeaderboard) {\n            if (['question', 'userInputs', 'results'].includes(this.currentScreen) && this.isScoredQuestion) {\n                return 'leaderboard';\n            } else if (this.isLastQuestion) {\n                return 'leaderboardFinal';\n            }\n        }\n        return 'nextQuestion';\n    },\n\n    /**\n     * Reverse behavior of '_getNextScreen'.\n     *\n     * @param {Event} ev\n     */\n    _getPreviousScreen: function () {\n        if (this.currentScreen === 'userInputs' && this.isScoredQuestion) {\n            return 'question';\n        } else if ((this.currentScreen === 'results' && this.isScoredQuestion) ||\n                  (this.currentScreen === 'leaderboard' && !this.isScoredQuestion) ||\n                  (this.currentScreen === 'leaderboardFinal' && this.isScoredQuestion)) {\n            return 'userInputs';\n        } else if ((this.currentScreen === 'leaderboard' && this.isScoredQuestion) ||\n                  (this.currentScreen === 'leaderboardFinal' && !this.isScoredQuestion)){\n            return 'results';\n        }\n\n        return 'previousQuestion';\n    },\n\n    /**\n    * We use a fade in/out mechanism to display the next question of the session.\n    *\n    * The fade out happens at the same moment as the _rpc to get the new question template.\n    * When they're both finished, we update the HTML of this widget with the new template and then\n    * fade in the updated question to the user.\n    *\n    * The timer (if configured) starts at the end of the fade in animation.\n    *\n    * @param {MouseEvent} ev\n    * @private\n    */\n    _nextQuestion: function (goBack) {\n        var self = this;\n\n        // stop calling multiple times \"get next question\" process until next question is fully loaded.\n        if (this.stopNextQuestion) {\n            return;\n        }\n        this.stopNextQuestion = true;\n\n        this.isStartScreen = false;\n        if (this.surveyTimerWidget) {\n            this.surveyTimerWidget.destroy();\n        }\n\n        var resolveFadeOut;\n        var fadeOutPromise = new Promise(function (resolve, reject) { resolveFadeOut = resolve; });\n        this.$el.fadeOut(this.fadeInOutTime, function () {\n            resolveFadeOut();\n        });\n\n        if (this.refreshBackground) {\n            $('div.o_survey_background').addClass('o_survey_background_transition');\n        }\n\n        // avoid refreshing results while transitioning\n        if (this.resultsRefreshInterval) {\n            clearInterval(this.resultsRefreshInterval);\n            delete this.resultsRefreshInterval;\n        }\n\n        var nextQuestionPromise = this._rpc({\n            route: _.str.sprintf('/survey/session/next_question/%s', self.surveyAccessToken),\n            params: {\n                'go_back': goBack,\n            }\n        }).then(function (result) {\n            self.nextQuestion = result;\n            if (self.refreshBackground && result.background_image_url) {\n                return self._preloadBackground(result.background_image_url);\n            } else {\n                return Promise.resolve();\n            }\n        });\n\n        Promise.all([fadeOutPromise, nextQuestionPromise]).then(function () {\n            return self._onNextQuestionDone(goBack);\n        });\n    },\n\n    _displaySessionClosedPage:function () {\n        this.$('.o_survey_question_header').addClass('invisible');\n        this.$('.o_survey_session_results, .o_survey_session_navigation_previous, .o_survey_session_navigation_next')\n            .addClass('d-none');\n        this.$('.o_survey_session_description_done').removeClass('d-none');\n    },\n\n    /**\n     * Refresh the screen with the next question's rendered template.\n     *\n     * @param {boolean} goBack Whether we are going back to the previous question or not\n     */\n    _onNextQuestionDone: async function (goBack) {\n        var self = this;\n\n        if (this.nextQuestion.question_html) {\n            var $renderedTemplate = $(this.nextQuestion.question_html);\n            this.$el.replaceWith($renderedTemplate);\n\n            // Ensure new question is fully loaded before force loading previous question screen.\n            await this.attachTo($renderedTemplate);\n            if (goBack) {\n                // As we arrive on \"question\" screen, simulate going to the results screen or leaderboard.\n                this._setShowInputs(true);\n                this._setShowAnswers(true);\n                if (this.sessionShowLeaderboard && this.isScoredQuestion) {\n                    this.currentScreen = 'leaderboard';\n                    this.leaderBoard.showLeaderboard(false, this.isScoredQuestion);\n                } else {\n                    this.currentScreen = 'results';\n                    this._refreshResults();\n                }\n            } else {\n                this._startTimer();\n            }\n            this.$el.fadeIn(this.fadeInOutTime);\n        } else if (this.sessionShowLeaderboard) {\n            // Display last screen if leaderboard activated\n            this.isLastQuestion = true;\n            this._setupLeaderboard().then(function () {\n                self.$('.o_survey_session_leaderboard_title').text(_t('Final Leaderboard'));\n                self.$('.o_survey_session_navigation_next').addClass('d-none');\n                self.$('.o_survey_leaderboard_buttons').removeClass('d-none');\n                self.leaderBoard.showLeaderboard(false, false);\n            });\n        } else {\n            self.$('.o_survey_session_close').first().click();\n            self._displaySessionClosedPage();\n        }\n\n        // Background Management\n        if (this.refreshBackground) {\n            $('div.o_survey_background').css(\"background-image\", \"url(\" + this.nextQuestion.background_image_url + \")\");\n            $('div.o_survey_background').removeClass('o_survey_background_transition');\n        }\n    },\n\n    /**\n     * Will start the question timer so that the host may know when the question is done to display\n     * the results and the leaderboard.\n     *\n     * If the question is scored, the timer ending triggers the display of attendees inputs.\n     */\n    _startTimer: function () {\n        var self = this;\n        var $timer = this.$('.o_survey_timer');\n\n        if ($timer.length) {\n            var timeLimitMinutes = this.$el.data('timeLimitMinutes');\n            var timer = this.$el.data('timer');\n            this.surveyTimerWidget = new publicWidget.registry.SurveyTimerWidget(this, {\n                'timer': timer,\n                'timeLimitMinutes': timeLimitMinutes\n            });\n            this.surveyTimerWidget.attachTo($timer);\n            this.surveyTimerWidget.on('time_up', this, function () {\n                if (self.currentScreen === 'question' && this.isScoredQuestion) {\n                    self.$('.o_survey_session_navigation_next').click();\n                }\n            });\n        }\n    },\n\n    /**\n     * Refreshes the question results.\n     *\n     * What we get from this call:\n     * - The 'question statistics' used to display the bar chart when appropriate\n     * - The 'user input lines' that are used to display text/date/datetime answers on the screen\n     * - The number of answers, useful for refreshing the progress bar\n     */\n    _refreshResults: function () {\n        var self = this;\n\n        return this._rpc({\n            route: _.str.sprintf('/survey/session/results/%s', self.surveyAccessToken)\n        }).then(function (questionResults) {\n            if (questionResults) {\n                self.attendeesCount = questionResults.attendees_count;\n\n                if (self.resultsChart && questionResults.question_statistics_graph) {\n                    self.resultsChart.updateChart(JSON.parse(questionResults.question_statistics_graph));\n                } else if (self.textAnswers) {\n                    self.textAnswers.updateTextAnswers(questionResults.input_line_values);\n                }\n\n                var max = self.attendeesCount > 0 ? self.attendeesCount : 1;\n                var percentage = Math.min(Math.round((questionResults.answer_count / max) * 100), 100);\n                self.$('.progress-bar').css('width', `${percentage}%`);\n\n                if (self.attendeesCount && self.attendeesCount > 0) {\n                    var answerCount = Math.min(questionResults.answer_count, self.attendeesCount);\n                    self.$('.o_survey_session_answer_count').text(answerCount);\n                    self.$('.progress-bar.o_survey_session_progress_small span').text(\n                        `${answerCount} / ${self.attendeesCount}`\n                    );\n                }\n            }\n\n            return Promise.resolve();\n        }, function () {\n            // on failure, stop refreshing\n            clearInterval(self.resultsRefreshInterval);\n            delete self.resultsRefreshInterval;\n        });\n    },\n\n    /**\n     * We refresh the attendees count every 2 seconds while the user is on the start screen.\n     *\n     */\n    _refreshAttendeesCount: function () {\n        var self = this;\n\n        return self._rpc({\n            model: 'survey.survey',\n            method: 'read',\n            args: [[self.surveyId], ['session_answer_count']],\n        }).then(function (result) {\n            if (result && result.length === 1){\n                self.$('.o_survey_session_attendees_count').text(\n                    result[0].session_answer_count\n                );\n            }\n        }, function () {\n            // on failure, stop refreshing\n            clearInterval(self.attendeesRefreshInterval);\n        });\n    },\n\n    /**\n     * For simple/multiple choice questions, we display a bar chart with:\n     *\n     * - answers of attendees\n     * - correct / incorrect answers when relevant\n     *\n     * see SurveySessionChart widget doc for more information.\n     *\n     */\n    _setupChart: function () {\n        if (this.resultsChart) {\n            this.resultsChart.setElement(null);\n            this.resultsChart.destroy();\n            delete this.resultsChart;\n        }\n\n        if (!this.isStartScreen && this.showBarChart) {\n            this.resultsChart = new SurveySessionChart(this, {\n                questionType: this.$el.data('questionType'),\n                answersValidity: this.$el.data('answersValidity'),\n                hasCorrectAnswers: this.hasCorrectAnswers,\n                questionStatistics: this.$el.data('questionStatistics'),\n                showInputs: this.showInputs\n            });\n\n            return this.resultsChart.attachTo(this.$('.o_survey_session_chart'));\n        } else {\n            return Promise.resolve();\n        }\n    },\n\n    /**\n     * Leaderboard of all the attendees based on their score.\n     * see SurveySessionLeaderBoard widget doc for more information.\n     *\n     */\n    _setupLeaderboard: function () {\n        if (this.leaderBoard) {\n            this.leaderBoard.setElement(null);\n            this.leaderBoard.destroy();\n            delete this.leaderBoard;\n        }\n\n        if (this.isScoredQuestion || this.isLastQuestion) {\n            this.leaderBoard = new SurveySessionLeaderBoard(this, {\n                surveyAccessToken: this.surveyAccessToken,\n                sessionResults: this.$('.o_survey_session_results')\n            });\n\n            return this.leaderBoard.attachTo(this.$('.o_survey_session_leaderboard'));\n        } else {\n            return Promise.resolve();\n        }\n    },\n\n    /**\n     * Shows attendees answers for char_box/date and datetime questions.\n     * see SurveySessionTextAnswers widget doc for more information.\n     *\n     */\n    _setupTextAnswers: function () {\n        if (this.textAnswers) {\n            this.textAnswers.setElement(null);\n            this.textAnswers.destroy();\n            delete this.textAnswers;\n        }\n\n        if (!this.isStartScreen && this.showTextAnswers) {\n            this.textAnswers = new SurveySessionTextAnswers(this, {\n                questionType: this.$el.data('questionType')\n            });\n\n            return this.textAnswers.attachTo(this.$('.o_survey_session_text_answers_container'));\n        } else {\n            return Promise.resolve();\n        }\n    },\n\n    /**\n     * Setup the 2 refresh intervals of 2 seconds for our widget:\n     * - The refresh of attendees count (only on the start screen)\n     * - The refresh of results (used for chart/text answers/progress bar)\n     */\n    _setupIntervals: function () {\n        this.attendeesCount = this.$el.data('attendeesCount') ? this.$el.data('attendeesCount') : 0;\n\n        if (this.isStartScreen) {\n            this.attendeesRefreshInterval = setInterval(this._refreshAttendeesCount.bind(this), 2000);\n        } else {\n            if (this.attendeesRefreshInterval) {\n                clearInterval(this.attendeesRefreshInterval);\n            }\n\n            if (!this.resultsRefreshInterval) {\n                this.resultsRefreshInterval = setInterval(this._refreshResults.bind(this), 2000);\n            }\n        }\n    },\n\n    /**\n     * Setup current screen based on question properties.\n     * If it's a non-scored question with a chart, we directly display the user inputs.\n     */\n    _setupCurrentScreen: function () {\n        if (this.isStartScreen) {\n            this.currentScreen = 'startScreen';\n        } else if (!this.isScoredQuestion && this.showBarChart) {\n            this.currentScreen = 'userInputs';\n        } else {\n            this.currentScreen = 'question';\n        }\n\n        this.$('.o_survey_session_navigation_previous').toggleClass('d-none', !!this.isFirstQuestion);\n\n        this._setShowInputs(this.currentScreen === 'userInputs');\n    },\n\n    /**\n     * When we go from the 'question' screen to the 'userInputs' screen, we toggle this boolean\n     * and send the information to the chart.\n     * The chart will show attendees survey.user_input.lines.\n     *\n     * @param {Boolean} showInputs\n     */\n    _setShowInputs(showInputs) {\n        this.showInputs = showInputs;\n\n        if (this.resultsChart) {\n            this.resultsChart.setShowInputs(showInputs);\n            this.resultsChart.updateChart();\n        }\n    },\n\n    /**\n     * When we go from the 'userInputs' screen to the 'results' screen, we toggle this boolean\n     * and send the information to the chart.\n     * The chart will show the question survey.question.answers.\n     * (Only used for simple / multiple choice questions).\n     *\n     * @param {Boolean} showAnswers\n     */\n    _setShowAnswers(showAnswers) {\n        this.showAnswers = showAnswers;\n\n        if (this.resultsChart) {\n            this.resultsChart.setShowAnswers(showAnswers);\n            this.resultsChart.updateChart();\n        }\n    }\n});\n\nreturn publicWidget.registry.SurveySessionManage;\n\n});\n"], "file": "/web/assets/2237-8b6a89c/1/survey.survey_user_input_session_assets.js", "sourceRoot": "../../../../"}